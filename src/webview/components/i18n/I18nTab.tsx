import { useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { useMetaStore } from '../../store/metaStore';
import { useCartStore } from '../../store/cartStore';
import { I18nToolbar } from './I18nToolbar';
import { TranslationTable } from './TranslationTable';
import { I18nStatusBar } from './I18nStatusBar';
import type { LocaleStrings, I18nData, I18nEntry } from '../../types';

interface I18nTabProps {
    locale: LocaleStrings;
    fontUri: string;
}

function isAscii(ch: string): boolean {
    return ch.charCodeAt(0) < 128;
}

function escHtml(s: string): string {
    return s
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
}

/** Render a single character to 8 bytes (LSB=leftmost pixel) using BoutiqueBitmap7x7 font */
function renderGlyphBytes(
    ch: string,
    ctx: CanvasRenderingContext2D | null
): number[] {
    if (!ctx) return [0, 0, 0, 0, 0, 0, 0, 0];
    ctx.clearRect(0, 0, 8, 8);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 8, 8);
    ctx.fillStyle = '#fff';
    ctx.font = '8px BoutiqueBitmap7x7';
    ctx.textBaseline = 'top';
    ctx.fillText(ch, 0, 0);
    const imgData = ctx.getImageData(0, 0, 8, 8);
    const bytes: number[] = [];
    for (let row = 0; row < 8; row++) {
        let b = 0;
        for (let col = 0; col < 8; col++) {
            const idx = (row * 8 + col) * 4;
            if (imgData.data[idx] > 128) {
                b |= 1 << col;
            }
        }
        bytes.push(b);
    }
    return bytes;
}

function generateCodegen(
    i18nData: I18nData,
    fontCtx: CanvasRenderingContext2D | null
): { lua: string; glyphCount: number; useSwap: boolean } | null {
    const loc = i18nData.outputLocale;
    if (!loc) return null;

    const uniqueChars: Record<string, number> = {};
    const charList: string[] = [];
    for (const entry of i18nData.entries) {
        const text = (entry.translations && entry.translations[loc]) || '';
        for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            if (!isAscii(ch) && uniqueChars[ch] === undefined) {
                uniqueChars[ch] = charList.length;
                charList.push(ch);
            }
        }
    }

    let glyphHex = '';
    for (const ch of charList) {
        const bytes = renderGlyphBytes(ch, fontCtx);
        for (const b of bytes) {
            glyphHex += ('0' + b.toString(16)).slice(-2);
        }
    }

    let gdStr = '';
    const bslash = '\\';
    for (let i = 0; i < glyphHex.length; i += 2) {
        gdStr += bslash + 'x' + glyphHex.substr(i, 2);
    }

    const tdLines: string[] = [];
    for (const entry of i18nData.entries) {
        const text = (entry.translations && entry.translations[loc]) || '';
        if (!text) continue;
        let mapped = '';
        let width = 0;
        for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            if (isAscii(ch)) {
                if (ch === '"') mapped += bslash + '"';
                else if (ch === bslash) mapped += bslash + bslash;
                else mapped += ch;
                width += 4;
            } else {
                const idx = uniqueChars[ch];
                const code = 128 + idx;
                mapped += bslash + code.toString();
                width += 8;
            }
        }
        tdLines.push(' ' + entry.key + '={w=' + width + ',s="' + mapped + '"}');
    }

    const useSwap = charList.length > 128;
    const nl = '\n';
    const p014 = bslash + '014';

    let lua = '';
    lua += '-- i18n runtime (generated by pico8ide)' + nl;
    lua += '-- locale: ' + loc + ', ' + charList.length + ' unique glyphs' + nl;
    if (glyphHex.length > 0) {
        lua += '_gd="' + gdStr + '"' + nl;
    }
    lua += '_td={' + nl;
    for (const l of tdLines) {
        lua += l + ',' + nl;
    }
    lua += '}' + nl + nl;

    if (!useSwap) {
        lua += 'function _txi()' + nl;
        lua += ' poke(0x5600,4)' + nl;
        lua += ' poke(0x5601,8)' + nl;
        lua += ' poke(0x5602,8)' + nl;
        if (glyphHex.length > 0) {
            lua += ' for i=1,#_gd do poke(0x59ff+i,ord(_gd,i)) end' + nl;
        }
        lua += 'end' + nl + nl;
        lua += 'function tx(k,x,y,c)' + nl;
        lua += ' local d=_td[k]' + nl;
        lua += ' if(d)print("' + p014 + '"..d.s,x,y,c)' + nl;
        lua += 'end' + nl + nl;
    } else {
        lua += '_gi={}' + nl + nl;
        lua += 'function _txi()' + nl;
        lua += ' poke(0x5600,4)' + nl;
        lua += ' poke(0x5601,8)' + nl;
        lua += ' poke(0x5602,8)' + nl;
        lua += 'end' + nl + nl;
        lua += 'function _txl(s)' + nl;
        lua += ' for i=1,#s do' + nl;
        lua += '  local c=ord(s,i)' + nl;
        lua += '  if c>=128 and not _gi[c] then' + nl;
        lua += '   local o=(c-128)*8+1' + nl;
        lua += '   for j=0,7 do poke(0x5a00+(c-128)*8+j,ord(_gd,o+j)) end' + nl;
        lua += '   _gi[c]=true' + nl;
        lua += '  end' + nl;
        lua += ' end' + nl;
        lua += 'end' + nl + nl;
        lua += 'function tx(k,x,y,c)' + nl;
        lua += ' local d=_td[k]' + nl;
        lua += ' if not d then return end' + nl;
        lua += ' _txl(d.s)' + nl;
        lua += ' print("' + p014 + '"..d.s,x,y,c)' + nl;
        lua += 'end' + nl + nl;
    }
    lua += 'function txw(k)' + nl;
    lua += ' local d=_td[k]' + nl;
    lua += ' return d and d.w or 0' + nl;
    lua += 'end' + nl;

    return { lua, glyphCount: charList.length, useSwap };
}

export function I18nTab({ locale, fontUri }: I18nTabProps) {
    const i18nData = useMetaStore((s) => s.i18nData);
    const setI18nData = useMetaStore((s) => s.setI18nData);
    const code = useCartStore((s) => s.code);

    const fontCtxRef = useRef<CanvasRenderingContext2D | null>(null);
    const [fontLoaded, setFontLoaded] = useState(false);
    const [copyLabel, setCopyLabel] = useState('Copy');
    const [hasScanned, setHasScanned] = useState(false);

    // Ensure we always have a valid i18nData object
    const data: I18nData = useMemo(
        () =>
            i18nData || {
                locales: [],
                entries: [],
                outputLocale: '',
            },
        [i18nData]
    );

    // Load the BoutiqueBitmap7x7 font
    useEffect(() => {
        const f = new FontFace('BoutiqueBitmap7x7', `url(${fontUri})`);
        f.load()
            .then((loaded) => {
                document.fonts.add(loaded);
                const canvas = document.createElement('canvas');
                canvas.width = 8;
                canvas.height = 8;
                fontCtxRef.current = canvas.getContext('2d', { willReadFrequently: true });
                setFontLoaded(true);
            })
            .catch(() => {
                const canvas = document.createElement('canvas');
                canvas.width = 8;
                canvas.height = 8;
                fontCtxRef.current = canvas.getContext('2d', { willReadFrequently: true });
                setFontLoaded(true);
            });
    }, [fontUri]);

    // Auto-scan on first render when we have code
    useEffect(() => {
        if (!hasScanned && fontLoaded && code) {
            handleScanCode();
            setHasScanned(true);
        }
    }, [fontLoaded, code]); // eslint-disable-line react-hooks/exhaustive-deps

    const updateI18nData = useCallback(
        (updater: (prev: I18nData) => I18nData) => {
            const current: I18nData = useMetaStore.getState().i18nData || {
                locales: [],
                entries: [],
                outputLocale: '',
            };
            setI18nData(updater(current));
        },
        [setI18nData]
    );

    const handleScanCode = useCallback(() => {
        const currentCode = useCartStore.getState().code;
        const re = /tx\(\s*"([^"]+)"\s*(?:,|\))/g;
        let m: RegExpExecArray | null;
        const foundKeys: Record<string, boolean> = {};
        while ((m = re.exec(currentCode)) !== null) {
            foundKeys[m[1]] = true;
        }
        updateI18nData((prev) => {
            // Remove entries whose keys no longer exist in code
            const filtered = prev.entries.filter((e) => foundKeys[e.key]);
            // Add new keys
            const existingKeys: Record<string, boolean> = {};
            filtered.forEach((e) => {
                existingKeys[e.key] = true;
            });
            const newEntries: I18nEntry[] = [...filtered];
            for (const k of Object.keys(foundKeys)) {
                if (!existingKeys[k]) {
                    const trans: Record<string, string> = {};
                    prev.locales.forEach((loc) => {
                        trans[loc] = '';
                    });
                    newEntries.push({ key: k, translations: trans });
                }
            }
            return { ...prev, entries: newEntries };
        });
    }, [updateI18nData]);

    const handleAddLocale = useCallback(
        (loc: string) => {
            updateI18nData((prev) => {
                if (prev.locales.indexOf(loc) >= 0) return prev;
                const newLocales = [...prev.locales, loc];
                const newEntries = prev.entries.map((e) => ({
                    ...e,
                    translations: { ...e.translations, [loc]: '' },
                }));
                return {
                    ...prev,
                    locales: newLocales,
                    entries: newEntries,
                    outputLocale: prev.outputLocale || loc,
                };
            });
        },
        [updateI18nData]
    );

    const handleRemoveLocale = useCallback(
        (loc: string) => {
            updateI18nData((prev) => {
                const newLocales = prev.locales.filter((l) => l !== loc);
                const newEntries = prev.entries.map((e) => {
                    const trans = { ...e.translations };
                    delete trans[loc];
                    return { ...e, translations: trans };
                });
                return {
                    ...prev,
                    locales: newLocales,
                    entries: newEntries,
                    outputLocale: prev.outputLocale === loc ? newLocales[0] || '' : prev.outputLocale,
                };
            });
        },
        [updateI18nData]
    );

    const handleOutputLocaleChange = useCallback(
        (loc: string) => {
            updateI18nData((prev) => ({
                ...prev,
                outputLocale: loc,
            }));
        },
        [updateI18nData]
    );

    const handleTranslationChange = useCallback(
        (entryIndex: number, loc: string, value: string) => {
            updateI18nData((prev) => {
                const newEntries = prev.entries.map((e, i) => {
                    if (i !== entryIndex) return e;
                    return {
                        ...e,
                        translations: { ...e.translations, [loc]: value },
                    };
                });
                return { ...prev, entries: newEntries };
            });
        },
        [updateI18nData]
    );

    const handleCopy = useCallback(() => {
        const cg = generateCodegen(data, fontCtxRef.current);
        if (cg) {
            navigator.clipboard.writeText(cg.lua).then(() => {
                setCopyLabel('Copied!');
                setTimeout(() => setCopyLabel('Copy'), 1500);
            });
        }
    }, [data]);

    // Generate codegen
    const codegen = useMemo(() => {
        if (!fontLoaded) return null;
        return generateCodegen(data, fontCtxRef.current);
    }, [data, fontLoaded]);

    return (
        <div className="i18n-editor">
            <I18nToolbar
                i18nData={data}
                onAddLocale={handleAddLocale}
                onRemoveLocale={handleRemoveLocale}
                onOutputLocaleChange={handleOutputLocaleChange}
                onScanCode={handleScanCode}
            />
            <TranslationTable
                i18nData={data}
                onTranslationChange={handleTranslationChange}
            />
            <div className="i18n-codegen">
                {codegen ? (
                    <>
                        <div className="codegen-header">
                            <span>
                                Generated Lua ({codegen.glyphCount} unique glyphs
                                {codegen.useSwap ? ' (swap mode)' : ''})
                            </span>
                            <button onClick={handleCopy}>{copyLabel}</button>
                        </div>
                        <pre>{codegen.lua}</pre>
                    </>
                ) : (
                    <div className="codegen-header">
                        <span>No output locale selected</span>
                    </div>
                )}
            </div>
            <I18nStatusBar i18nData={data} />
        </div>
    );
}
