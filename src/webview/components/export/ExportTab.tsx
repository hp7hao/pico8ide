import { useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { useMetaStore } from '../../store/metaStore';
import { useCartStore } from '../../store/cartStore';
import { useVscodeMessage, postMessage } from '../../hooks/useVscodeMessaging';
import { TemplatePicker } from './TemplatePicker';
import { ExportPreview } from './ExportPreview';
import { ExportButtons } from './ExportButtons';
import type { LocaleStrings, I18nData } from '../../types';

interface ExportTabProps {
    locale: LocaleStrings;
}

function isAscii(ch: string): boolean {
    return ch.charCodeAt(0) < 128;
}

/** Render a single character to 8 bytes (LSB=leftmost pixel) using BoutiqueBitmap7x7 font */
function renderGlyphBytes(
    ch: string,
    ctx: CanvasRenderingContext2D | null
): number[] {
    if (!ctx) return [0, 0, 0, 0, 0, 0, 0, 0];
    ctx.clearRect(0, 0, 8, 8);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 8, 8);
    ctx.fillStyle = '#fff';
    ctx.font = '8px BoutiqueBitmap7x7';
    ctx.textBaseline = 'top';
    ctx.fillText(ch, 0, 0);
    const imgData = ctx.getImageData(0, 0, 8, 8);
    const bytes: number[] = [];
    for (let row = 0; row < 8; row++) {
        let b = 0;
        for (let col = 0; col < 8; col++) {
            const idx = (row * 8 + col) * 4;
            if (imgData.data[idx] > 128) {
                b |= 1 << col;
            }
        }
        bytes.push(b);
    }
    return bytes;
}

function exportGenerateI18nLua(
    loc: string,
    i18nData: I18nData,
    fontCtx: CanvasRenderingContext2D | null
): string {
    const uniqueChars: Record<string, number> = {};
    const charList: string[] = [];
    for (const entry of i18nData.entries) {
        const text = (entry.translations && entry.translations[loc]) || '';
        for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            if (!isAscii(ch) && uniqueChars[ch] === undefined) {
                uniqueChars[ch] = charList.length;
                charList.push(ch);
            }
        }
    }

    let glyphHex = '';
    for (const ch of charList) {
        const bytes = renderGlyphBytes(ch, fontCtx);
        for (const b of bytes) {
            glyphHex += ('0' + b.toString(16)).slice(-2);
        }
    }

    let gdStr = '';
    const bslash = '\\';
    for (let i = 0; i < glyphHex.length; i += 2) {
        gdStr += bslash + 'x' + glyphHex.substr(i, 2);
    }

    const tdLines: string[] = [];
    for (const entry of i18nData.entries) {
        const text = (entry.translations && entry.translations[loc]) || '';
        if (!text) continue;
        let mapped = '';
        let width = 0;
        for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            if (isAscii(ch)) {
                if (ch === '"') mapped += bslash + '"';
                else if (ch === bslash) mapped += bslash + bslash;
                else mapped += ch;
                width += 4;
            } else {
                const idx = uniqueChars[ch];
                const code = 128 + idx;
                mapped += bslash + code.toString();
                width += 8;
            }
        }
        tdLines.push(' ' + entry.key + '={w=' + width + ',s="' + mapped + '"}');
    }

    const useSwap = charList.length > 128;
    const nl = '\n';
    const p014 = bslash + '014';

    let lua = '';
    lua += '-- i18n runtime (generated by pico8ide)' + nl;
    lua += '-- locale: ' + loc + ', ' + charList.length + ' unique glyphs' + nl;
    if (glyphHex.length > 0) {
        lua += '_gd="' + gdStr + '"' + nl;
    }
    lua += '_td={' + nl;
    for (const l of tdLines) {
        lua += l + ',' + nl;
    }
    lua += '}' + nl + nl;

    if (!useSwap) {
        lua += 'function _txi()' + nl;
        lua += ' poke(0x5600,4)' + nl;
        lua += ' poke(0x5601,8)' + nl;
        lua += ' poke(0x5602,8)' + nl;
        if (glyphHex.length > 0) {
            lua += ' for i=1,#_gd do poke(0x59ff+i,ord(_gd,i)) end' + nl;
        }
        lua += 'end' + nl + nl;
        lua += 'function tx(k,x,y,c)' + nl;
        lua += ' local d=_td[k]' + nl;
        lua += ' if(d)print("' + p014 + '"..d.s,x,y,c)' + nl;
        lua += 'end' + nl + nl;
    } else {
        lua += '_gi={}' + nl + nl;
        lua += 'function _txi()' + nl;
        lua += ' poke(0x5600,4)' + nl;
        lua += ' poke(0x5601,8)' + nl;
        lua += ' poke(0x5602,8)' + nl;
        lua += 'end' + nl + nl;
        lua += 'function _txl(s)' + nl;
        lua += ' for i=1,#s do' + nl;
        lua += '  local c=ord(s,i)' + nl;
        lua += '  if c>=128 and not _gi[c] then' + nl;
        lua += '   local o=(c-128)*8+1' + nl;
        lua += '   for j=0,7 do poke(0x5a00+(c-128)*8+j,ord(_gd,o+j)) end' + nl;
        lua += '   _gi[c]=true' + nl;
        lua += '  end' + nl;
        lua += ' end' + nl;
        lua += 'end' + nl + nl;
        lua += 'function tx(k,x,y,c)' + nl;
        lua += ' local d=_td[k]' + nl;
        lua += ' if not d then return end' + nl;
        lua += ' _txl(d.s)' + nl;
        lua += ' print("' + p014 + '"..d.s,x,y,c)' + nl;
        lua += 'end' + nl + nl;
    }
    lua += 'function txw(k)' + nl;
    lua += ' local d=_td[k]' + nl;
    lua += ' return d and d.w or 0' + nl;
    lua += 'end' + nl;

    return lua;
}

export function ExportTab({ locale }: ExportTabProps) {
    const meta = useMetaStore((s) => s.meta);
    const i18nData = useMetaStore((s) => s.i18nData);
    const setMetaField = useMetaStore((s) => s.setMetaField);
    const label = useCartStore((s) => s.label);

    const initData = window.__INIT_DATA__;
    const templatePreviews = initData.templatePreviews;
    const fontUri = initData.fontUri;

    const fontCtxRef = useRef<CanvasRenderingContext2D | null>(null);
    const [fontLoaded, setFontLoaded] = useState(false);
    const [statusMessage, setStatusMessage] = useState('');
    const [statusColor, setStatusColor] = useState('#888');

    const i18n: I18nData = useMemo(
        () =>
            i18nData || {
                locales: [],
                entries: [],
                outputLocale: '',
            },
        [i18nData]
    );

    // Load font
    useEffect(() => {
        const f = new FontFace('BoutiqueBitmap7x7', `url(${fontUri})`);
        f.load()
            .then((loaded) => {
                document.fonts.add(loaded);
                const canvas = document.createElement('canvas');
                canvas.width = 8;
                canvas.height = 8;
                fontCtxRef.current = canvas.getContext('2d', { willReadFrequently: true });
                setFontLoaded(true);
            })
            .catch(() => {
                const canvas = document.createElement('canvas');
                canvas.width = 8;
                canvas.height = 8;
                fontCtxRef.current = canvas.getContext('2d', { willReadFrequently: true });
                setFontLoaded(true);
            });
    }, [fontUri]);

    // Listen for export results from extension
    const handleMessage = useCallback(
        (msg: any) => {
            if (msg.type === 'exportComplete') {
                const fileName = (msg.path || '').split('/').pop()?.split('\\').pop() || '';
                setStatusMessage(locale.exportSuccess + ': ' + fileName);
                setStatusColor('#8f8');
            }
            if (msg.type === 'exportError') {
                setStatusMessage(locale.exportError + ': ' + msg.error);
                setStatusColor('#f66');
            }
            if (msg.type === 'exportBatchComplete') {
                if (msg.errors && msg.errors.length > 0) {
                    setStatusMessage(
                        msg.paths.length + ' exported, ' + msg.errors.length + ' failed: ' + msg.errors.join(', ')
                    );
                    setStatusColor('#fa0');
                } else {
                    setStatusMessage(
                        locale.exportSuccess + ': ' + msg.paths.length + ' files (' + msg.paths.join(', ') + ')'
                    );
                    setStatusColor('#8f8');
                }
            }
        },
        [locale]
    );

    useVscodeMessage(handleMessage);

    const collectGlyphs = useCallback(
        (text: string): Record<string, number[]> => {
            const glyphs: Record<string, number[]> = {};
            for (let i = 0; i < text.length; i++) {
                const ch = text[i];
                if (!glyphs[ch]) {
                    glyphs[ch] = renderGlyphBytes(ch, fontCtxRef.current);
                }
            }
            return glyphs;
        },
        []
    );

    const getLocaleMeta = useCallback(
        (variant: string) => {
            let locTitle = '';
            let locAuthor = '';
            for (const e of i18n.entries) {
                if (e.key === '_title' && e.translations && e.translations[variant]) {
                    locTitle = e.translations[variant];
                }
                if (e.key === '_author' && e.translations && e.translations[variant]) {
                    locAuthor = e.translations[variant];
                }
            }
            if (locTitle || locAuthor) {
                return {
                    title: locTitle || meta.title,
                    author: locAuthor || meta.author,
                };
            }
            return null;
        },
        [i18n.entries, meta.title, meta.author]
    );

    const handleExportBase = useCallback(() => {
        setStatusMessage('Exporting...');
        setStatusColor('#888');

        const allText = (meta.title || '') + (meta.author || '');
        const glyphs = collectGlyphs(allText);

        postMessage({
            type: 'exportCart',
            variant: 'base',
            glyphs,
            i18nLuaCode: null,
            localeMeta: null,
        });
    }, [meta.title, meta.author, collectGlyphs]);

    const handleExportLocale = useCallback(
        (variant: string) => {
            setStatusMessage('Exporting...');
            setStatusColor('#888');

            const localeMeta = getLocaleMeta(variant);
            const allText = localeMeta
                ? localeMeta.title + localeMeta.author
                : (meta.title || '') + (meta.author || '');
            const glyphs = collectGlyphs(allText);
            const i18nLuaCode = exportGenerateI18nLua(variant, i18n, fontCtxRef.current);

            postMessage({
                type: 'exportCart',
                variant,
                glyphs,
                i18nLuaCode,
                localeMeta,
            });
        },
        [meta.title, meta.author, i18n, collectGlyphs, getLocaleMeta]
    );

    const handleExportAll = useCallback(() => {
        setStatusMessage('Exporting all...');
        setStatusColor('#888');

        const variants = ['base', ...i18n.locales];
        const items = variants.map((variant) => {
            let localeMeta: { title: string; author: string } | null = null;
            let i18nLuaCode: string | null = null;
            let allText = (meta.title || '') + (meta.author || '');

            if (variant !== 'base') {
                localeMeta = getLocaleMeta(variant);
                if (localeMeta) {
                    allText = localeMeta.title + localeMeta.author;
                }
                i18nLuaCode = exportGenerateI18nLua(variant, i18n, fontCtxRef.current);
            }

            const glyphs = collectGlyphs(allText);
            return { variant, glyphs, i18nLuaCode, localeMeta };
        });

        postMessage({ type: 'exportCartBatch', items });
    }, [meta.title, meta.author, i18n, collectGlyphs, getLocaleMeta]);

    const handleTemplateSelect = useCallback(
        (template: string) => {
            setMetaField('template', template);
        },
        [setMetaField]
    );

    return (
        <div className="export-editor">
            <div className="export-body">
                <div className="export-form">
                    <div>
                        <label>{locale.exportTitle}</label>
                        <input
                            type="text"
                            value={meta.title}
                            placeholder="Game Title"
                            onChange={(e) => setMetaField('title', e.target.value)}
                        />
                    </div>
                    <div>
                        <label>{locale.exportAuthor}</label>
                        <input
                            type="text"
                            value={meta.author}
                            placeholder="Author"
                            onChange={(e) => setMetaField('author', e.target.value)}
                        />
                    </div>
                    <TemplatePicker
                        locale={locale}
                        selected={meta.template}
                        templatePreviews={templatePreviews}
                        onSelect={handleTemplateSelect}
                    />
                    <ExportButtons
                        locale={locale}
                        locales={i18n.locales}
                        statusMessage={statusMessage}
                        statusColor={statusColor}
                        onExportBase={handleExportBase}
                        onExportLocale={handleExportLocale}
                        onExportAll={handleExportAll}
                    />
                </div>
                <ExportPreview
                    template={meta.template}
                    title={meta.title}
                    author={meta.author}
                    templatePreviews={templatePreviews}
                    labelDataUrl={label}
                    fontLoaded={fontLoaded}
                />
            </div>
            <div className="export-status">
                {statusMessage && (
                    <span style={{ color: statusColor }}>{statusMessage}</span>
                )}
            </div>
        </div>
    );
}
